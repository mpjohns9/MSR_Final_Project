#!/usr/bin/env python

import rospy
from visualization_msgs.msg import MarkerArray, Marker
from generate.generate_maze import MazeGeneration
from gazebo_msgs.srv import SpawnModel, DeleteModel
from maze_gen.srv import GenerateMaze
from geometry_msgs.msg import Pose
import numpy as np

class Maze:

    def __init__(self):
        self.marker_pub = rospy.Publisher('maze_markers', Marker, queue_size=100)
        self.spawn_model = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
        self.delete_model = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
        self.generate_maze = rospy.Service('generate_maze', GenerateMaze, self.create_markers)
        # self.difficulty = rospy.get_param('~difficulty')
        self.viz = rospy.get_param('~viz')
        self.markers = []
        self.ma = MarkerArray()
        self.r = rospy.Rate(0.5)
        self.maze = None
        self.mg = MazeGeneration()

        if self.viz != 'rviz':
            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/wall.sdf', 'r') as f1:
                self.wall_xml = f1.read()

            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/sphere.sdf', 'r') as f2:
                self.sphere_xml = f2.read()

            rospy.wait_for_service("gazebo/spawn_sdf_model")

    def vel_callback(self, maze):
        print(self.mg.solve_maze(maze))

    def create_markers(self, difficulty):
        # rospy.logerr('Generating maze...')
        self.maze = self.mg.generate_maze(difficulty)

        self.maze[4][4] = 4

        end_found = False
        row = -3
        while not end_found:
            if 2 in self.maze[row]:
                # print('index')
                idx = np.where(self.maze[row] == 2)[0]
                print(idx)
                if len(idx) > 1:
                    print('INDEX:', idx[-1])
                    self.maze[row][idx[-1]] = 5
                else:
                    self.maze[row][idx] = 5
                end_found = True
            row -= 1

        # self.vel_callback(self.maze)

        id = 0
        print('Maze:',self.maze)
        for y, row in enumerate(self.maze):
            # print('Row:',row)
            for x, c in enumerate(row):
                # print('Cell:', c)
                if c in (1, 4, 5):
                    # if c == 4:
                        # print('starting location', x, y)

                    marker = Marker()
                    marker.header.frame_id = 'map'
                    marker.id = id
                    marker.action = marker.ADD
                    marker.scale.x = 0.2
                    marker.scale.y = 0.2
                    marker.scale.z = 0.1

                    if c == 1:
                        marker.type = marker.CUBE
                        marker.color.r = 1.0
                        marker.color.g = 0.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    elif c == 4:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 1.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    else:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 0.0
                        marker.color.b = 1.0
                        marker.color.a = 1.0


                    p = Pose()

                    p.orientation.w = 1.0
                    p.position.x = x/(len(self.maze)/5) - 2.5
                    p.position.y = y/(len(self.maze)/5) - 2.5
                    p.position.z = 0
                    # print(p.position)

                    marker.pose = p

                    if self.viz != 'rviz':
                        if c == 5:
                            self.delete_model(f'wall{y*len(row) + x}')
                            self.spawn_model(f'sphere_start', self.sphere_xml, '', p, 'world')
                        elif c == 4:
                            self.delete_model(f'wall{y*len(row) + x}')

                    self.markers.append(marker)
                    # rospy.logerr('MARKER')
                    # rospy.logerr(marker)
                    # rospy.logerr('__________________________________')
                    self.marker_pub.publish(marker)

                    id += 1

                else:
                    if self.viz != 'rviz':
                        self.delete_model(f'wall{y*len(row) + x}')

        return []

        # self.ma.markers = self.markers

        # id = 0
        # for m in self.ma.markers:
        #     m.id = id
        #     id += 1
            # rospy.logerr(m)

def main():
    rospy.init_node('maze')
    maze = Maze()
    # maze.create_markers()
    while not rospy.is_shutdown():
        # maze.create_markers()
        # rospy.logerr(maze.markers)
        # maze.marker_pub.publish(maze.ma)
        maze.r.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

