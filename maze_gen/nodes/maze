#!/usr/bin/env python

import rospy
from visualization_msgs.msg import MarkerArray, Marker
from generate.generate_maze import MazeGeneration
from generate.svm import SVM
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SpawnModel, DeleteModel, SetModelState
from maze_gen.srv import GenerateMaze
from geometry_msgs.msg import Pose, Twist
from std_msgs.msg import Int8
from std_srvs.srv import Empty, EmptyResponse
from nav_msgs.msg import Odometry
import numpy as np
import tf
import queue
from enum import Enum
# from generate.data_collection import DataPipeline

class MoveState(Enum):
    WAITING = 0
    MOVING = 1
    FINISHED = 2

class Maze:

    def __init__(self):
        self.marker_pub = rospy.Publisher('maze_markers', Marker, queue_size=100)
        self.vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=100)

        self.pose_sub = rospy.Subscriber('odom', Odometry, self.get_pose)
        self.data_sub = rospy.Subscriber('sp_input', Int8, self.get_data)

        self.spawn_model = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
        self.delete_model = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
        self.set_model_state = rospy.ServiceProxy('gazebo/set_model_state', SetModelState)

        self.generate_maze = rospy.Service('generate_maze', GenerateMaze, self.create_markers)
        self.move = rospy.Service('move', Empty, self.move)
        self.save_data = rospy.Service('save_data', Empty, self.save_data)
        self.save_data = rospy.Service('process_data', Empty, self.process_data)


        # self.difficulty = rospy.get_param('~difficulty')
        self.viz = rospy.get_param('~viz')

        self.markers = []
        self.ma = MarkerArray()
        self.r = rospy.Rate(100)
        self.maze = []
        self.mg = MazeGeneration()
        self.svm = SVM()
        # self.data = DataPipeline()
        self.path = []
        self.velocity = (0, 0) # (angular, linear)
        self.waypoint = None
        self.position = None
        self.orientation = None

        self.data = []
        # self.data_received = False
        self.sensor_vals = queue.Queue()

        self.move_state = MoveState.WAITING

        if self.viz != 'rviz':
            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/wall.sdf', 'r') as f1:
                self.wall_xml = f1.read()

            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/sphere.sdf', 'r') as f2:
                self.sphere_xml = f2.read()

            rospy.wait_for_service("gazebo/spawn_sdf_model")

    def get_data(self, d):
        self.sensor_vals.put(d.data)
        # self.data_received = True

    def save_data(self, req):
        print(self.data)

    def process_data(self, req):
        print(self.svm.process_data(self.data))

    def get_pose(self, p):
        pos = p.pose.pose.position
        orient = [
            p.pose.pose.orientation.x,
            p.pose.pose.orientation.y,
            p.pose.pose.orientation.z,
            p.pose.pose.orientation.w
        ]
        self.position = (pos.x, pos.y)
        self.orientation = tf.transformations.euler_from_quaternion(orient)[2]

    def move(self, req):
        if len(self.maze) > 0:
            self.move_state = MoveState.MOVING
            self.path = self.mg.solve_maze(self.maze, self.position)
            self.set_next_command()
        else:
            rospy.logerr('No maze has been built. Generate maze first (/generate_maze) and try again.')

    def set_next_command(self):
        p = self.path.pop(0)
        self.velocity = (p[0], p[1])

        coords = self.mg.generate_waypoint(self.position, p[2])
        self.waypoint = (*coords, self.orientation+(p[0]*6))

    def generate_vel(self):
        # print('Current Pos:', self.position)
        # print('Waypoint:', self.waypoint)
        if self.velocity[0] == 0:
            if np.abs(self.waypoint[0]-self.position[0]) > 0.01 or \
                    np.abs(self.waypoint[1]-self.position[1]) > 0.01:
                return
            else:
                if len(self.path) > 0:
                    self.set_next_command()
                else:
                    self.move_state = MoveState.FINISHED
        else:
            rospy.logerr(f'Orientation: {self.orientation}')
            rospy.logerr(f'Waypoint: {self.waypoint[2]}')
            if np.abs(self.orientation-self.waypoint[2]) > 0.01:
                return
            else:
                if len(self.path) > 0:
                    self.set_next_command()
                else:
                    self.move_state = MoveState.FINISHED

    def create_markers(self, req):
        # rospy.logerr('Generating maze...')
        self.maze = self.mg.generate_maze(int(req.difficulty))
        
        self.maze[4][4] = 4

        end_found = False
        row = -3
        while not end_found:
            if 2 in self.maze[row]:
                # print('index')
                idx = np.where(self.maze[row] == 2)[0]
                print(idx)
                if len(idx) > 1:
                    print('INDEX:', idx[-1])
                    self.maze[row][idx[-1]] = 5
                else:
                    self.maze[row][idx] = 5
                end_found = True
            row -= 1

        # self.vel_callback(self.maze)

        id = 0
        print('Maze:',self.maze)
        for y, row in enumerate(self.maze):
            # print('Row:',row)
            for x, c in enumerate(row):
                # print('Cell:', c)
                if c in (1, 4, 5):
                    # if c == 4:
                        # print('starting location', x, y)

                    marker = Marker()
                    marker.header.frame_id = 'world'
                    marker.id = id
                    marker.action = marker.ADD
                    marker.scale.x = 0.2
                    marker.scale.y = 0.2
                    marker.scale.z = 0.1

                    if c == 1:
                        marker.type = marker.CUBE
                        marker.color.r = 1.0
                        marker.color.g = 0.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    elif c == 4:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 1.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    else:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 0.0
                        marker.color.b = 1.0
                        marker.color.a = 1.0


                    p = Pose()

                    p.orientation.w = 1.0
                    p.position.x = x/(len(self.maze)/5) - 2.5
                    p.position.y = y/(len(self.maze)/5) - 2.5
                    p.position.z = -0.125
                    # print(p.position)

                    marker.pose = p
                    # self.spawn_model(f'wall_{id}', self.wall_xml, '', p, 'world')
                    if self.viz != 'rviz':
                        if c == 1:
                            ms = ModelState()
                            ms.model_name = f'wall_{id}'
                            ms.pose = p

                            self.set_model_state(ms)
                    #     if c == 5:
                    #         self.delete_model(f'wall{y*len(row) + x}')
                    #         self.spawn_model(f'sphere_start', self.sphere_xml, '', p, 'world')
                    #     elif c == 4:
                    #         self.delete_model(f'wall{y*len(row) + x}')

                    self.markers.append(marker)
                    # rospy.logerr('MARKER')
                    # rospy.logerr(marker)
                    # rospy.logerr('__________________________________')
                    self.marker_pub.publish(marker)

                    id += 1

                # else:
                #     if self.viz != 'rviz':
                #         self.delete_model(f'wall{y*len(row) + x}')

        return []

        # self.ma.markers = self.markers

        # id = 0
        # for m in self.ma.markers:
        #     m.id = id
        #     id += 1
            # rospy.logerr(m)

def main():
    rospy.init_node('maze')
    maze = Maze()
    # maze.create_markers()
    v = Twist()
    while not rospy.is_shutdown():
        # maze.data.print_data()

        # if maze.moving:
        if maze.move_state == MoveState.MOVING:
            maze.generate_vel()
            v.linear.x = maze.velocity[1]
            v.angular.z = maze.velocity[0]
            maze.vel_pub.publish(v)

            if not maze.sensor_vals.empty():
                maze.data.append(maze.sensor_vals.get_nowait())
            else:
                maze.data.append(0)

        elif maze.move_state == MoveState.WAITING:
            v.linear.x = 0
            v.angular.z = 0
            maze.vel_pub.publish(v)

        else:
            v.linear.x = 0
            v.angular.z = 0
            maze.vel_pub.publish(v)

            if not maze.sensor_vals.empty():
                maze.data.append(maze.sensor_vals.get_nowait())

        # maze.create_markers()
        # rospy.logerr(maze.markers)
        # maze.marker_pub.publish(maze.ma)
        maze.r.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

