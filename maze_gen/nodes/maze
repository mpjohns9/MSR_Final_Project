#!/usr/bin/env python

"""Generates maze simulation in Rviz/Gazebo for data collection.
Also can be run without maze to reduce data collection time.
Processes and saves data collected to csv for model training.

PUBLISHERS: 
    + maze_markers (Marker): Markers that make up maze walls
    + cmd_vel (Twist): Velocity of turtlebot

SUBSCRIBERS:
    + odom (Odometry): Pose of turtlebot
    + sp_input (Int8): Input received from sip and puff sensor

SERVICES:
    + generate_maze (GenerateMaze): Takes difficulty input and generates random maze
    + move (Empty): Starts turtlebot in motion through maze
    + save_data (Empty): Saves data collected to csv file
    + print_data (Empty): Prints both current trials data and corresponding labels
    + process_data (Empty): Converts collected data inputs from 450 long to 150
    + reset (Empty): Resets maze, robot, and data in simulation
    + toggle_control_mode (Empty): Toggles between simlulated and manual control modes
    + collect_data (Empty): Begins facilitated data collection with prompt for ground truth
"""

import rospy
from visualization_msgs.msg import MarkerArray, Marker
from generate.generate_maze import MazeGeneration
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SpawnModel, DeleteModel, SetModelState
from maze_gen.srv import GenerateMaze
from geometry_msgs.msg import Pose, Twist
from std_msgs.msg import Int8
from std_srvs.srv import Empty, EmptyResponse
from nav_msgs.msg import Odometry
import numpy as np
import pandas as pd
import tf
import queue
from enum import Enum
import os
import datetime as dt
from tensorflow.keras.models import load_model

class MoveState(Enum):
    WAITING = 0
    MOVING = 1
    FINISHED = 2
    MANUAL = 3

class MoveActions(Enum):
    STOP = 0
    FORWARD = 1
    LEFT_TURN = 2
    RIGHT_TURN = 3
    # CONTINUE = 4
    
class Maze:

    def __init__(self):

        self.viz = rospy.get_param('~viz')
        self.control_mode = rospy.get_param('~control')

        self.test_num = 2
        self.initial_pos = None

        self.markers = []
        self.ma = MarkerArray()
        self.r = rospy.Rate(100)
        self.maze = []
        self.mg = MazeGeneration()
        self.path = []
        self.velocity = (0, 0) # (angular, linear)
        self.waypoint = None
        self.position = None
        self.orientation = None

        self.trials = []
        self.data = []
        self.live_vals = []
        self.last_change = dt.datetime.now()

        self.ground_truth = []
        self.labels = []

        self.dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

        if self.control_mode != 'sim':
            self.model = self.load_model()
            self.move_state = MoveState.MANUAL
        else:
            self.move_state = MoveState.WAITING

        self.control_map = {
            0: (0, 0),
            1: (0, 5/46*2),
            2: (np.pi/12, 0),
            3: (-np.pi/12, 0),
            4: None
        }

        self.marker_pub = rospy.Publisher('maze_markers', Marker, queue_size=100)
        self.vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=100)

        self.pose_sub = rospy.Subscriber('odom', Odometry, self.get_pose)
        self.data_sub = rospy.Subscriber('sp_input', Int8, self.get_data)

        self.spawn_model = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
        self.delete_model = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
        self.set_model_state = rospy.ServiceProxy('gazebo/set_model_state', SetModelState)
        self.pause_sim = rospy.ServiceProxy('gazebo/pause_physics', Empty)
        self.unpause_sim = rospy.ServiceProxy('gazebo/unpause_physics', Empty)

        self.generate_maze = rospy.Service('generate_maze', GenerateMaze, self.create_markers)
        self.move = rospy.Service('move', Empty, self.move)
        self.save_data = rospy.Service('save_data', Empty, self.save_data)
        self.print_data = rospy.Service('print_data', Empty, self.print_data)
        self.process_data = rospy.Service('process_data', Empty, self.process_data)
        self.reset = rospy.Service('reset', Empty, self.reset)
        self.toggle_control_mode = rospy.Service('toggle_control_mode', Empty, self.toggle_control_mode)
        self.collect_data = rospy.Service('collect_data', Empty, self.collect_data)

        if self.viz != 'rviz':
            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/wall.sdf', 'r') as f1:
                self.wall_xml = f1.read()

            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/sphere.sdf', 'r') as f2:
                self.sphere_xml = f2.read()

            rospy.wait_for_service("gazebo/spawn_sdf_model")

    def get_pose(self, p):
        if not self.initial_pos:
            self.initial_pos = p

        pos = p.pose.pose.position
        orient = [
            p.pose.pose.orientation.x,
            p.pose.pose.orientation.y,
            p.pose.pose.orientation.z,
            p.pose.pose.orientation.w
        ]
        self.position = (pos.x, pos.y)
        self.orientation = tf.transformations.euler_from_quaternion(orient)[2]

    def get_data(self, d):
        previous = self.live_vals.copy()
        if len(self.live_vals) >= 450:
            if np.abs(d.data) > 5:
                if (dt.datetime.now()-self.last_change).seconds > 1:
                    self.live_vals = [0.0 for i in range(450)]
                    self.check_for_change = 0
                
                self.live_vals.append(d.data)
                self.live_vals = self.live_vals[-450:] 
            
        else:
            if np.abs(d.data) > 5:
                self.live_vals.append(d.data)

        if previous != self.live_vals:
            self.last_change = dt.datetime.now()

    def create_markers(self, req):
        self.unpause_sim()
        self.maze = self.mg.generate_maze(int(req.difficulty))
        
        self.maze[4][4] = 4

        end_found = False
        row = -3
        while not end_found:
            if 2 in self.maze[row]:
                idx = np.where(self.maze[row] == 2)[0]
                print(idx)
                if len(idx) > 1:
                    print('INDEX:', idx[-1])
                    self.maze[row][idx[-1]] = 5
                else:
                    self.maze[row][idx] = 5
                end_found = True
            row -= 1

        id = 0
        print('Maze:',self.maze)
        for y, row in enumerate(self.maze):
            for x, c in enumerate(row):
                if c in (1, 4, 5):

                    marker = Marker()
                    marker.header.frame_id = 'world'
                    marker.id = id
                    marker.action = marker.ADD
                    marker.scale.x = 0.2
                    marker.scale.y = 0.2
                    marker.scale.z = 0.1

                    if c == 1:
                        marker.type = marker.CUBE
                        marker.color.r = 1.0
                        marker.color.g = 0.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    elif c == 4:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 1.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    else:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 0.0
                        marker.color.b = 1.0
                        marker.color.a = 1.0


                    p = Pose()

                    p.orientation.w = 1.0
                    p.position.x = x/(len(self.maze)/5) - 2.5
                    p.position.y = y/(len(self.maze)/5) - 2.5
                    p.position.z = -0.125

                    marker.pose = p
                    if self.viz != 'rviz':
                        if c == 1:
                            ms = ModelState()
                            ms.model_name = f'wall_{id}'
                            ms.pose = p

                            self.set_model_state(ms)

                    self.markers.append(marker)
                    self.marker_pub.publish(marker)

                    id += 1

        return []

    def move(self, req):
        if len(self.maze) > 0:
            self.move_state = MoveState.MOVING
            self.path = self.mg.solve_maze(self.maze, self.position)
            self.set_next_command()
        else:
            rospy.logerr('No maze has been built. Generate maze first (/generate_maze) and try again.')

        return EmptyResponse()

    def toggle_control_mode(self, req):
        if self.control_mode == 'sim':
            self.control_mode = 'manual'
            self.move_state = MoveState.MANUAL
            self.model = self.load_model()
        else:
            self.control_mode == 'sim'

    def reset(self, req):
        self.move_state = MoveState.WAITING
        self.data = []
        self.sensor_vals = queue.Queue()
        self.ground_truth = []

        id = 0
        for y, row in enumerate(self.maze):
            for x, c in enumerate(row):
                if c in (1, 4, 5):
                    p = Pose()

                    p.orientation.w = 1.0
                    p.position.x = x/(len(self.maze)/5) - 2.5
                    p.position.y = y/(len(self.maze)/5) - 2.5
                    p.position.z = -1000000

                    if self.viz != 'rviz' and c == 1:
                        ms = ModelState()
                        ms.model_name = f'wall_{id}'
                        ms.pose = p

                        self.set_model_state(ms)

                    id += 1

        ms = ModelState()
        ms.model_name = 'robot'
        ms.pose = self.initial_pos.pose.pose
        self.set_model_state(ms)
        return EmptyResponse()

    def collect_data(self, req):
        filtered = self.trim_data(self.live_vals)
        self.trials.append(filtered)
        print('Data Collected:\n', filtered)
        print()
        label = input('Enter ground truth value...\n')
        self.labels.append(label)
        self.live_vals = []
        print()
        return EmptyResponse()

    def print_data(self, req):
        print('Trials: ', self.trials)
        print('Labels: ', self.labels)
        return EmptyResponse()
    
    def save_data(self, req):
        self.trials = pd.DataFrame(self.trials)
        self.trials['labels'] = self.labels
        print('Data to be saved:\n')
        print(self.trials)
        save = input('Proceed with saving? (Press Y to save)\n')
        if save == 'y':
            self.trials.to_csv(f'{self.dir}/data/test_results_{dt.datetime.now()}.csv')
            print('Data saved successfully.')
            self.test_num += 1
        else:
            print('Data was not saved.')
        return EmptyResponse()

    def process_data(self, req):
        self.trials = [self.trim_data(t) for t in self.trials]
        return EmptyResponse()

    def load_model(self):
        """Loads trained model.

        Change directory to load different model.

        Returns:
            Sequential: Model loaded from directory
        """
        return load_model(f'{self.dir}/data/cnn_synthetic_augmentedv2.h5')

    def trim_data(self, data):
        """Trims data input to only include every third item.

        Args:
            data (list): List of data to be trimmed
        Returns:
            ndarray: List of data with only every third item remaining
        """
        return np.array(data[::3])

    def generate_prompt(self, text):
        """Publishes text marker.

        Args:
            text (str): Text to be displayed as marker
        """

        marker = Marker()
        marker.header.frame_id = 'world'
        marker.id = 99999
        marker.action = marker.ADD
        marker.scale.x = 0.1
        marker.scale.y = 0.1
        marker.scale.z = 0.1
        marker.type = marker.TEXT_VIEW_FACING
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 0.0
        marker.color.a = 1.0

        p = Pose()
        p.orientation.w = 1.0
        p.position.x = self.position[0]
        p.position.y = self.position[1]
        p.position.z = 1.25
        marker.pose = p

        marker.lifetime = rospy.Duration(2.5)

        marker.text = text

        self.marker_pub.publish(marker)

    def set_next_command(self):
        """Sets new velocity and waypoint."""

        p = self.path.pop(0)
        self.velocity = (p[0], p[1])

        coords = self.mg.generate_waypoint(self.position, p[2])
        self.waypoint = (*coords, self.orientation+(p[0]*6))

    def generate_vel(self):
        """Checks if new command needs to be generated.

        If waypoint has been reached, calls function to generate
        new waypoint. Otherwise, if end of path has been reached 
        changes state to finished; if not, does nothing.
        """

        if self.velocity[0] == 0:
            if np.abs(self.waypoint[0]-self.position[0]) > 0.01 or \
                    np.abs(self.waypoint[1]-self.position[1]) > 0.01:
                return
            else:
                if len(self.path) > 0:
                    self.set_next_command()
                else:
                    self.move_state = MoveState.FINISHED
        else:
            if np.abs(self.orientation-self.waypoint[2]) > 0.01:
                return
            else:
                if len(self.path) > 0:
                    self.set_next_command()
                else:
                    self.move_state = MoveState.FINISHED
                    self.trials.append(self.data)

def main():
    """Does one of the following based on control mode:

    If mode is 'sim':
    Collects sip and puff input from user at certain points in time
    (when robot changes move action) for specified duration. At the 
    same time, publishes velocity commands to turtlebot to navigate 
    through maze simulation.

    If mode is 'manual':
    Collects sip and puff input and classifies using loaded network model.
    Publishes velocity commands to turtlebot based on predictions.
    """

    rospy.init_node('maze')
    maze = Maze()
    v = Twist()
    prev_gt = None
    collect = False
    counter = 0
    while not rospy.is_shutdown():
        if maze.control_mode == 'sim':
            if maze.move_state == MoveState.MOVING:
                if counter >= 150:
                    collect = False
                    maze.trials.append(maze.live_vals)
                    maze.labels.append(round(np.mean(maze.ground_truth)))
                    maze.ground_truth = []
                    counter = 0

                maze.generate_vel()
                v.linear.x = maze.velocity[1]
                v.angular.z = maze.velocity[0]
                maze.vel_pub.publish(v)

                if v.linear.x != 0:
                    gt = MoveActions.FORWARD.value
                elif v.angular.z > 0:
                    gt = MoveActions.LEFT_TURN.value
                elif v.angular.z < 0: 
                    gt = MoveActions.RIGHT_TURN.value

                if prev_gt != gt and len(maze.path) > 1:
                    collect = True
                    if gt == MoveActions.FORWARD.value:
                        text = 'Move Forward'
                        maze.generate_prompt(text)
                    elif gt == MoveActions.LEFT_TURN.value:
                        text = 'Turn Left'
                        maze.generate_prompt(text)
                    elif gt == MoveActions.RIGHT_TURN.value:
                        text = 'Turn Right'
                        maze.generate_prompt(text)
                elif len(maze.path) <= 1:
                    collect = True
                    text = 'Slow down and Stop'
                    maze.generate_prompt(text)
                    gt = MoveActions.STOP.value
                
                prev_gt = gt

                if collect:
                    maze.ground_truth.append(gt)
                    counter += 1

            elif maze.move_state == MoveState.WAITING:
                v.linear.x = 0
                v.angular.z = 0
                maze.vel_pub.publish(v)

            else:
                v.linear.x = 0
                v.angular.z = 0
                maze.vel_pub.publish(v)

        else:
            
            if len(maze.live_vals) >= 450:
                data = maze.trim_data(maze.live_vals)
                print('Sensor data:', data)
                data = data.reshape(1, data.shape[0], 1)
                pred = np.argmax(maze.model.predict(data), axis=1)
                print('Prediction', pred)

                if maze.control_map[pred[0]]:
                    v.angular.z, v.linear.x = maze.control_map[pred[0]]

                maze.vel_pub.publish(v)
            
        maze.r.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

