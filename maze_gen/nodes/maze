#!/usr/bin/env python

from tracemalloc import stop
import rospy
from visualization_msgs.msg import MarkerArray, Marker
from generate.generate_maze import MazeGeneration
from generate.cnn import CNN
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SpawnModel, DeleteModel, SetModelState
from maze_gen.srv import GenerateMaze
from geometry_msgs.msg import Pose, Twist
from std_msgs.msg import Int8
from std_srvs.srv import Empty, EmptyResponse
from nav_msgs.msg import Odometry
import numpy as np
import pandas as pd
import tf
import queue
from enum import Enum
import os
import datetime as dt
from tensorflow.keras.models import load_model
# from generate.data_collection import DataPipeline

class MoveState(Enum):
    WAITING = 0
    MOVING = 1
    FINISHED = 2
    MANUAL = 3

class MoveActions(Enum):
    STOP = 0
    FORWARD = 1
    LEFT_TURN = 2
    RIGHT_TURN = 3
    # CONTINUE = 4
    
class Maze:

    def __init__(self):
        self.marker_pub = rospy.Publisher('maze_markers', Marker, queue_size=100)
        self.vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=100)

        self.pose_sub = rospy.Subscriber('odom', Odometry, self.get_pose)
        self.data_sub = rospy.Subscriber('sp_input', Int8, self.get_data)

        self.spawn_model = rospy.ServiceProxy('gazebo/spawn_sdf_model', SpawnModel)
        self.delete_model = rospy.ServiceProxy('gazebo/delete_model', DeleteModel)
        self.set_model_state = rospy.ServiceProxy('gazebo/set_model_state', SetModelState)
        self.pause_sim = rospy.ServiceProxy('gazebo/pause_physics', Empty)
        self.unpause_sim = rospy.ServiceProxy('gazebo/unpause_physics', Empty)

        self.generate_maze = rospy.Service('generate_maze', GenerateMaze, self.create_markers)
        self.move = rospy.Service('move', Empty, self.move)
        self.save_data = rospy.Service('save_data', Empty, self.save_data)
        self.print_data = rospy.Service('print_data', Empty, self.print_data)
        self.process_data = rospy.Service('process_data', Empty, self.process_data)
        self.reset = rospy.Service('reset', Empty, self.reset)
        self.toggle_control_mode = rospy.Service('toggle_control_mode', Empty, self.toggle_control_mode)
        self.toggle_control_mode = rospy.Service('collect_data', Empty, self.collect_data)

        # self.difficulty = rospy.get_param('~difficulty')
        self.viz = rospy.get_param('~viz')
        self.control_mode = rospy.get_param('~control')

        self.test_num = 2
        self.initial_pos = None

        self.markers = []
        self.ma = MarkerArray()
        self.r = rospy.Rate(100)
        self.maze = []
        self.mg = MazeGeneration()
        self.cnn = CNN()
        # self.data = DataPipeline()
        self.path = []
        self.velocity = (0, 0) # (angular, linear)
        self.waypoint = None
        self.position = None
        self.orientation = None

        self.trials = []
        self.data = []
        # self.data_received = False
        self.sensor_vals = queue.Queue()
        self.live_vals = []
        self.check_for_change = 0
        # self.live_queue = queue.LifoQueue()

        self.ground_truth = []
        self.labels = []

        self.dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        print(self.dir)

        if self.control_mode != 'sim':
            self.model = self.load_model()
            self.move_state = MoveState.MANUAL
        else:
            self.move_state = MoveState.WAITING

        self.control_map = {
            0: (0, 0),
            1: (0, 5/46*2),
            2: (np.pi/12, 0),
            3: (-np.pi/12, 0),
            4: None
        }

        if self.viz != 'rviz':
            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/wall.sdf', 'r') as f1:
                self.wall_xml = f1.read()

            with open('/home/mpjohns/cdir/FinalProject/ws/src/final_project/maze_gen/urdf/sphere.sdf', 'r') as f2:
                self.sphere_xml = f2.read()

            rospy.wait_for_service("gazebo/spawn_sdf_model")

    def load_model(self):
        return load_model(f'{self.dir}/data/cnn_synthetic_augmented_user4.h5')

    def generate_prompt(self, text):
        marker = Marker()
        marker.header.frame_id = 'world'
        marker.id = 99999
        marker.action = marker.ADD
        marker.scale.x = 0.1
        marker.scale.y = 0.1
        marker.scale.z = 0.1
        marker.type = marker.TEXT_VIEW_FACING
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 0.0
        marker.color.a = 1.0

        p = Pose()
        p.orientation.w = 1.0
        p.position.x = self.position[0]
        p.position.y = self.position[1]
        p.position.z = 1.25
        marker.pose = p

        marker.lifetime = rospy.Duration(2.5)

        marker.text = text

        self.marker_pub.publish(marker)

    def toggle_control_mode(self, req):
        print(self.control_mode)
        print(self.control_mode == 'sim')
        if self.control_mode == 'sim':
            self.control_mode = 'manual'
            self.move_state = MoveState.MANUAL
            self.model = self.load_model()
        else:
            self.control_mode == 'sim'
        print(self.control_mode)

    def reset(self, req):
        self.move_state = MoveState.WAITING
        self.data = []
        self.sensor_vals = queue.Queue()
        self.ground_truth = []

        id = 0
        for y, row in enumerate(self.maze):
            for x, c in enumerate(row):
                if c in (1, 4, 5):
                    p = Pose()

                    p.orientation.w = 1.0
                    p.position.x = x/(len(self.maze)/5) - 2.5
                    p.position.y = y/(len(self.maze)/5) - 2.5
                    p.position.z = -1000000

                    if self.viz != 'rviz' and c == 1:
                        ms = ModelState()
                        ms.model_name = f'wall_{id}'
                        ms.pose = p

                        self.set_model_state(ms)

                    id += 1

        ms = ModelState()
        ms.model_name = 'robot'
        ms.pose = self.initial_pos.pose.pose
        self.set_model_state(ms)


        # self.pause_sim()
    
    def get_data(self, d):
        # print(d.data)
        self.sensor_vals.put(d.data)
        previous = self.live_vals.copy()
        if len(self.live_vals) >= 450:
            if np.abs(d.data) > 5:
                if self.check_for_change > 75:
                    self.live_vals = [0.0 for i in range(450)]
                    self.check_for_change = 0
                
                self.live_vals.append(d.data)
                self.live_vals = self.live_vals[-450:] 
            
        else:
            self.live_vals.append(d.data)

        if previous == self.live_vals:
            self.check_for_change += 1


        

        # self.test.append(d.data)
        # if self.move_state == MoveState.MOVING:
        #     self.sensor_vals.put(d.data)
        # elif self.move_state == MoveState.MANUAL:
        #     self.live_queue.put(d.data)
        # self.data_received = True

    def collect_data(self, req):
        filtered = self.live_vals[::3]
        self.trials.append(filtered)
        print('Data Collected:\n', filtered)
        print()
        label = input('Enter ground truth value...\n')
        self.labels.append(label)
        self.live_vals = []
        print()

    def print_data(self, req):
        if self.sensor_vals.empty():
            print(self.data)
        else:
            print(f'Data still being recorded. Please try again.')
    
    def save_data(self, req):
        self.trials = pd.DataFrame(self.trials)
        self.trials['labels'] = self.labels
        print('Data to be saved:\n')
        print(self.trials)
        save = input('Proceed with saving? (Press Y to save)\n')
        if save == 'y':
            self.trials.to_csv(f'{self.dir}/data/test_results_{dt.datetime.now()}.csv')
            print('Data saved successfully.')
            self.test_num += 1
        else:
            print('Data was not saved.')

    def process_data(self, req):
        print(len(self.ground_truth))
        print(len(self.data))
        if len(self.ground_truth) < len(self.data):
            self.data = self.data[:len(self.ground_truth)]
        elif len(self.data) < len(self.ground_truth):
            self.ground_truth = self.ground_truth[:len(self.data)]

        print(len(self.ground_truth))
        print(len(self.data))

        # print(self.ground_truth)
        # self.ground_truth = self.ground_truth[:-1000]
        # self.ground_truth.extend([MoveActions.STOP.value for i in range(100)])
        # print(len(self.ground_truth))
        
        self.labels = self.cnn.process_data(self.ground_truth, labels=True)
        self.trials = self.cnn.process_data(self.data)
        print(len(self.labels))
        print(len(self.trials))

    def get_pose(self, p):
        if not self.initial_pos:
            self.initial_pos = p

        pos = p.pose.pose.position
        orient = [
            p.pose.pose.orientation.x,
            p.pose.pose.orientation.y,
            p.pose.pose.orientation.z,
            p.pose.pose.orientation.w
        ]
        self.position = (pos.x, pos.y)
        self.orientation = tf.transformations.euler_from_quaternion(orient)[2]

    def move(self, req):
        if len(self.maze) > 0:
            self.move_state = MoveState.MOVING
            self.path = self.mg.solve_maze(self.maze, self.position)
            self.set_next_command()
        else:
            rospy.logerr('No maze has been built. Generate maze first (/generate_maze) and try again.')

    def set_next_command(self):
        p = self.path.pop(0)
        self.velocity = (p[0], p[1])

        coords = self.mg.generate_waypoint(self.position, p[2])
        self.waypoint = (*coords, self.orientation+(p[0]*6))

    def generate_vel(self):
        # print('Current Pos:', self.position)
        # print('Waypoint:', self.waypoint)
        if self.velocity[0] == 0:
            if np.abs(self.waypoint[0]-self.position[0]) > 0.01 or \
                    np.abs(self.waypoint[1]-self.position[1]) > 0.01:
                return
            else:
                if len(self.path) > 0:
                    self.set_next_command()
                else:
                    self.move_state = MoveState.FINISHED
                    self.trials.append(self.data)
        else:
            # rospy.logerr(f'Orientation: {self.orientation}')
            # rospy.logerr(f'Waypoint: {self.waypoint[2]}')
            if np.abs(self.orientation-self.waypoint[2]) > 0.01:
                return
            else:
                if len(self.path) > 0:
                    self.set_next_command()
                else:
                    self.move_state = MoveState.FINISHED
                    self.trials.append(self.data)

    def create_markers(self, req):
        self.unpause_sim()
        # rospy.logerr('Generating maze...')
        self.maze = self.mg.generate_maze(int(req.difficulty))
        
        self.maze[4][4] = 4

        end_found = False
        row = -3
        while not end_found:
            if 2 in self.maze[row]:
                # print('index')
                idx = np.where(self.maze[row] == 2)[0]
                print(idx)
                if len(idx) > 1:
                    print('INDEX:', idx[-1])
                    self.maze[row][idx[-1]] = 5
                else:
                    self.maze[row][idx] = 5
                end_found = True
            row -= 1

        # self.vel_callback(self.maze)

        id = 0
        print('Maze:',self.maze)
        for y, row in enumerate(self.maze):
            # print('Row:',row)
            for x, c in enumerate(row):
                # print('Cell:', c)
                if c in (1, 4, 5):
                    # if c == 4:
                        # print('starting location', x, y)

                    marker = Marker()
                    marker.header.frame_id = 'world'
                    marker.id = id
                    marker.action = marker.ADD
                    marker.scale.x = 0.2
                    marker.scale.y = 0.2
                    marker.scale.z = 0.1

                    if c == 1:
                        marker.type = marker.CUBE
                        marker.color.r = 1.0
                        marker.color.g = 0.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    elif c == 4:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 1.0
                        marker.color.b = 0.0
                        marker.color.a = 1.0
                    else:
                        marker.type = marker.SPHERE
                        marker.color.r = 0.0
                        marker.color.g = 0.0
                        marker.color.b = 1.0
                        marker.color.a = 1.0


                    p = Pose()

                    p.orientation.w = 1.0
                    p.position.x = x/(len(self.maze)/5) - 2.5
                    p.position.y = y/(len(self.maze)/5) - 2.5
                    p.position.z = -0.125
                    # print(p.position)

                    marker.pose = p
                    # self.spawn_model(f'wall_{id}', self.wall_xml, '', p, 'world')
                    if self.viz != 'rviz':
                        if c == 1:
                            ms = ModelState()
                            ms.model_name = f'wall_{id}'
                            ms.pose = p

                            self.set_model_state(ms)
                    #     if c == 5:
                    #         self.delete_model(f'wall{y*len(row) + x}')
                    #         self.spawn_model(f'sphere_start', self.sphere_xml, '', p, 'world')
                    #     elif c == 4:
                    #         self.delete_model(f'wall{y*len(row) + x}')

                    self.markers.append(marker)
                    # rospy.logerr('MARKER')
                    # rospy.logerr(marker)
                    # rospy.logerr('__________________________________')
                    self.marker_pub.publish(marker)

                    id += 1

                # else:
                #     if self.viz != 'rviz':
                #         self.delete_model(f'wall{y*len(row) + x}')

        return []

        # self.ma.markers = self.markers

        # id = 0
        # for m in self.ma.markers:
        #     m.id = id
        #     id += 1
            # rospy.logerr(m)

def main():
    rospy.init_node('maze')
    maze = Maze()
    # maze.create_markers()
    v = Twist()
    prev_gt = None
    collect = False
    counter = 0
    while not rospy.is_shutdown():
        # maze.data.print_data()
        # print(maze.control_mode)
        # print(maze.live_vals)
        if maze.control_mode == 'sim':
            # if maze.moving:
            if maze.move_state == MoveState.MOVING:
                # Add stop label to beginning of sim
                # if counter < 100:
                #     v.linear.x = 0
                #     v.angular.z = 0
                #     maze.vel_pub.publish(v)

                #     maze.ground_truth.append(0)

                #     if not maze.sensor_vals.empty():
                #         maze.data.append(maze.sensor_vals.get_nowait())
                #     else:
                #         maze.data.append(0)

                #     counter += 1
                #     maze.r.sleep()
                #     continue

                if counter >= 150:
                    collect = False
                    counter = 0

                maze.generate_vel()
                v.linear.x = maze.velocity[1]
                v.angular.z = maze.velocity[0]
                maze.vel_pub.publish(v)

                if v.linear.x != 0:
                    gt = MoveActions.FORWARD.value
                elif v.angular.z > 0:
                    gt = MoveActions.LEFT_TURN.value
                elif v.angular.z < 0: 
                    gt = MoveActions.RIGHT_TURN.value

                if prev_gt != gt and len(maze.path) > 1:
                    collect = True
                    if gt == MoveActions.FORWARD.value:
                        text = 'Move Forward'
                        maze.generate_prompt(text)
                    elif gt == MoveActions.LEFT_TURN.value:
                        text = 'Turn Left'
                        maze.generate_prompt(text)
                    elif gt == MoveActions.RIGHT_TURN.value:
                        text = 'Turn Right'
                        maze.generate_prompt(text)
                elif len(maze.path) <= 1:
                    collect = True
                    text = 'Slow down and Stop'
                    maze.generate_prompt(text)
                    gt = MoveActions.STOP.value
                
                prev_gt = gt

                maze.ground_truth.append(gt)
                # print(maze.ground_truth)

                if collect:
                    if not maze.sensor_vals.empty():
                        maze.data.append(maze.sensor_vals.get_nowait())
                    else:
                        maze.data.append(0)
                    
                    counter += 1

            

            elif maze.move_state == MoveState.WAITING:
                v.linear.x = 0
                v.angular.z = 0
                maze.vel_pub.publish(v)

            else:
                v.linear.x = 0
                v.angular.z = 0
                maze.vel_pub.publish(v)

                if not maze.sensor_vals.empty() and collect and counter < 150:
                    maze.data.append(maze.sensor_vals.get_nowait())
                    counter += 1
                    
            # maze.create_markers()
            # rospy.logerr(maze.markers)
            # maze.marker_pub.publish(maze.ma)
        else:
            # TODO: Reduce latency of sipnpuff signals.

            # if not maze.sensor_vals.empty():
            #     maze.data.append(maze.sensor_vals.get_nowait())
            # else:
            #     maze.data.append(0)
            
            if len(maze.live_vals) >= 450:
            #     print(maze.test)
            #     maze.data = maze.data[-150:]
            #     print('Sensor data:', maze.test)
            #     # data = np.array(maze.data[::-1])
            #     data = np.array(maze.data)
            #     data = data.reshape(1, data.shape[0], 1)
            #     pred = np.argmax(maze.model.predict(data), axis=1)
            #     print('Prediction', pred)

            #     if maze.control_map[pred[0]]:
            #         v.angular.z, v.linear.x = maze.control_map[pred[0]]

            #     maze.vel_pub.publish(v)
            # print(maze.test)
                data = np.array(maze.live_vals[::3])
                print('Sensor data:', data)
                # data = np.array(maze.data[::-1])
                # data = np.array(maze.test)
                data = data.reshape(1, data.shape[0], 1)
                pred = np.argmax(maze.model.predict(data), axis=1)
                print('Prediction', pred)

                if maze.control_map[pred[0]]:
                    v.angular.z, v.linear.x = maze.control_map[pred[0]]

                maze.vel_pub.publish(v)
            

        maze.r.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

